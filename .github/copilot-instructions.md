# Gym Buddy — Agent Guide

Mono-repo: Spring Boot 4.0 backend (Java 25, hexagonal) + Angular 21 frontend (Bun, signals, Tailwind v4).

## Build / Test / Lint Commands

### Backend (run from `backend/`)
```
mvn spring-boot:run                          # start on :8080
mvn test                                     # all tests (unit + ArchUnit)
mvn test -Dtest=UserControllerTest           # single test class
mvn test -Dtest=UserControllerTest#shouldGetAllUsers  # single test method
mvn clean verify                             # full build + test (CI)
```

### Frontend (run from `frontend/`, package manager: Bun)
```
bun install                                  # install deps
bun run start                                # dev server on :4200 (proxies /api to :8080)
bun run build                                # production build to dist/
bun run test -- --watch=false                # Vitest unit tests
bun run test -- --watch=false --include **/users.page.spec.ts  # exact file
bun run test:ci                              # tests with V8 coverage
bun run lint                                 # lint
bun run depcruise                            # boundary checks
bun run e2e                                  # Playwright E2E (Chromium)
```

### Docker
```
docker-compose up -d backend                 # containerized backend
docker-compose up                            # full stack
```

## Architecture — Hexagonal (Backend)

Base package: `com.gymbuddy`. Three rings with strict dependency rules enforced by ArchUnit:

| Ring | Package | May depend on | Must NOT depend on |
|---|---|---|---|
| Domain | `domain/{entity,value,exception}` | JDK only (+ Lombok currently) | application, adapter, Spring, JPA |
| Application | `application/{port/in,port/out,service}` | domain | adapter |
| Adapters | `adapter/{inbound,outbound,config}` | application, domain, Spring | — |

### Naming conventions
- Inbound ports: `*UseCase` (interfaces in `application/port/in/`)
- Outbound ports: `*Port` (interfaces in `application/port/` or `application/port/out/`)
- Services: `*Service` in `application/service/`, annotated `@Service @RequiredArgsConstructor`
- Controllers: `*Controller` in `adapter/inbound/controller/`, implements OpenAPI-generated `*Api`
- DTOs: generated by OpenAPI plugin into `adapter/inbound/controller/dto/`, suffixed `Dto`
- JPA entities: `*JpaEntity` in `adapter/outbound/persistence/`
- JPA repos: `*JpaRepository` extends `JpaRepository<>`
- Persistence adapters: `*RepositoryAdapter` implements `*Port`
- Mappers: `*Mapper` (MapStruct interfaces, `@Mapper` annotation)
  - Inbound: `adapter/inbound/controller/mapper/` (domain <-> DTO)
  - Outbound: `adapter/outbound/persistence/mapper/` (domain <-> JPA entity)

### Key rules
- Controllers are thin: validate -> map -> call use-case -> map response. Depend on `*UseCase`, never `*Service` directly.
- Never expose domain objects over HTTP; always map to DTOs.
- JPA entities never leak outside outbound persistence adapter.
- Value objects (e.g., `UserId`) use private constructor + static `of()` factory, manual `equals`/`hashCode`/`toString`.
- Domain exceptions: `DomainException`, `ResourceNotFoundException` (both extend `RuntimeException`).
- Global error handling: `GlobalExceptionHandler` (`@ControllerAdvice`) maps exceptions to HTTP status codes.
- DB: H2 in-memory. Schema in `schema.sql`, seed data in `data.sql`.
- OpenAPI: single `openapi.yml` generates both backend interfaces/DTOs and frontend API client.

## Architecture — Frontend

### Folder structure
```
frontend/src/app/
  core/                    # bootstrap, global infra
    api/                   # OpenAPI-generated client (DO NOT edit — regenerated by Maven)
    adapters/              # manual adapters wrapping core/api if needed
    services/              # global services
  pages/                   # route-level page components
    {feature}/             # e.g. pages/users/
      {feature}.page.ts
      {feature}.page.spec.ts
  shared/                  # cross-cutting reusables
    components/
    directives/
    pipes/
    utils/
```

### Import rules (enforced by dependency-cruiser)
- `core/` must NOT import from `pages/`
- `shared/` must NOT import from `core/` or `pages/`
- `pages/` features must NOT cross-import each other
- Outside `core/api/`, import only through the barrel `core/api/index.ts`
- No circular dependencies

### Angular conventions
- **Standalone components only** (no NgModules). Components use `imports: [...]` directly.
- **OnPush change detection** is the default (configured in `angular.json` schematics).
- **Signals-first**: use `signal()`, `computed()`, `effect()`. RxJS only when signals are insufficient.
- `rxResource` for async data fetching (from `@angular/core/rxjs-interop`).
- Signal-based forms: `form()`, `required()`, `email()` from `@angular/forms/signals`.
- **Inline templates and styles** by default (per `angular.json` schematics). Templates may use `templateUrl` when large.
- Component selector prefix: `app-` (kebab-case). Directive prefix: `app` (camelCase).
- Page components: class named `*Page`, selector `app-{feature}`, file `{feature}.page.ts`.
- Protect component internals with `protected` or `readonly` where appropriate.

## Code Style

### Java
- **Formatting**: 2-space indent (IDE config). Opening brace on same line. Blank line between methods.
- **Local variables**: prefer `final var` for type inference (`final var users = ...`).
- **Method params**: mark `final` (`public ResponseEntity<UserDto> getUserById(final Long id)`).
- **Imports**: explicit imports, no wildcards. Order: project imports, then `java.*`, then third-party.
- **Annotations**: Lombok `@Getter @Setter @Builder @RequiredArgsConstructor @AllArgsConstructor @NoArgsConstructor` on adapter/application classes. Domain should avoid Lombok (current code uses it — follow existing pattern until refactored).
- **No `@Autowired` field injection** (enforced by ArchUnit). Use constructor injection via `@RequiredArgsConstructor`.
- **Javadoc**: on public classes and port interfaces. Test classes get a one-line class-level doc.
- **Tests**: JUnit 5 + Mockito. `@ExtendWith(MockitoExtension.class)`, `@Mock`, `@InjectMocks`. Sections: `// Given`, `// When`, `// Then`. Method names: `should{Expected}` or `should{Expected}When{Condition}`.

### TypeScript / Angular
- **Formatting**: Prettier — 100 char line width, single quotes, 2-space indent, trailing newline.
- **HTML**: parsed with `angular` parser by Prettier.
- **Strict TypeScript**: `strict: true`, `noImplicitReturns`, `noFallthroughCasesInSwitch`, `noPropertyAccessFromIndexSignature`.
- **Imports**: named imports from specific modules. Use barrel `index.ts` exports for `core/api`.
- **Vitest globals**: `describe`, `it`, `expect`, `vi` are globally available (no import needed).
- **Test structure**: `describe('ComponentName', () => { it('does X', async () => { ... }) })`.
- **Test setup**: `TestBed.configureTestingModule({ imports: [Component], providers: [...mocks] })`. Mock services with `vi.fn()`.
- **Tailwind CSS v4**: utility-first, no custom CSS unless unavoidable. No separate `tailwind.config` file (v4 PostCSS plugin).
- **SCSS**: style language is `scss` (per `angular.json`), but prefer Tailwind utilities over custom SCSS.

## Error Handling

### Backend
- Domain validation: throw `IllegalArgumentException` with descriptive message.
- Resource not found: throw `ResourceNotFoundException` (domain exception).
- Business rule violations: throw `DomainException`.
- `GlobalExceptionHandler` maps: `ResourceNotFoundException` -> 404, `DomainException` -> 400, `IllegalArgumentException` -> 400, unhandled `Exception` -> 500 (generic message, no stack leak).

### Frontend
- `rxResource` exposes `.error()` signal — use `computed()` to derive error state.
- HTTP errors in manual subscribes: `subscribe({ error: (err) => console.error(...) })`.
- Template: `@if (loadError())` blocks for user-facing error messages.

## CI (`.github/workflows/`)
- **test.yml**: push/PR to `main`. Backend: Java 25, `mvn clean verify`. Frontend: `bun run test:ci`, `bun run lint`.
- **docker.yml**: after test passes on `main`. Multi-stage Docker build, pushes to GHCR.
- **e2e.yml**: after Docker build. Playwright against containerized app.

## Git Conventions
- Branches: `feature/<summary>` or `fix/<summary>`
- Commits: describe **why**, not what. Group backend + frontend changes per logical unit.
- Never commit secrets or `.env` files.
- TDD cadence: red -> green -> refactor. No production code without a failing test.
